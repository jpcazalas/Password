//
//  main.cpp
//  password
//
//  Created by Jean-Philippe Cazalas on 14/01/2024.
//
#include <iostream>
#include <string>
#include <sqlite3.h>

using namespace std;

const int MAX_SIZE = 100; // Maximum number of credentials
string encryptionKey = "123456"; // Global encryption key

class PasswordManager {
public:
    virtual void addPassword(const string& website, const string& username, const string& password) = 0;
    virtual void displayPasswords(bool decrypt = false) const = 0;
    virtual void deletePassword(const string& website) = 0;
    virtual ~PasswordManager() {}
};

class SimpleEncryption {
public:
    static string encrypt(const string& input) {
        string result = input;
        for (size_t i = 0; i < result.length(); ++i) {
            result[i] = result[i] ^ encryptionKey[i % encryptionKey.length()];
        }
        return result;
    }

    static string decrypt(const string& input) {
        return encrypt(input); // Decryption is the same as encryption
    }
};

class SQLitePasswordManager : public PasswordManager {
private:
    sqlite3* db;
    int count;

public:
    SQLitePasswordManager() {
        int rc = sqlite3_open("passwords.db", &db);
        if (rc != SQLITE_OK) {
            cerr << "Cannot open the database: " << sqlite3_errmsg(db) << endl;
            exit(1);
        }

        // Create a table if not exists
        const char* createTableQuery = "CREATE TABLE IF NOT EXISTS passwords (id INTEGER PRIMARY KEY, website TEXT, username TEXT, password TEXT);";
        rc = sqlite3_exec(db, createTableQuery, 0, 0, 0);
        if (rc != SQLITE_OK) {
            cerr << "Cannot create table: " << sqlite3_errmsg(db) << endl;
            exit(1);
        }

        count = 0;
    }

    ~SQLitePasswordManager() {
        sqlite3_close(db);
    }

    void addPassword(const string& website, const string& username, const string& password) override {
        if (count < MAX_SIZE) {
            // Insert the password into the SQLite database
            string encryptedPassword = SimpleEncryption::encrypt(password);
            string insertQuery = "INSERT INTO passwords (website, username, password) VALUES (?, ?, ?);";
            sqlite3_stmt* stmt;
            int rc = sqlite3_prepare_v2(db, insertQuery.c_str(), -1, &stmt, 0);
            if (rc != SQLITE_OK) {
                cerr << "Error preparing SQL statement: " << sqlite3_errmsg(db) << endl;
                return;
            }

            // Bind parameters
            sqlite3_bind_text(stmt, 1, website.c_str(), -1, SQLITE_STATIC);
            sqlite3_bind_text(stmt, 2, username.c_str(), -1, SQLITE_STATIC);
            sqlite3_bind_text(stmt, 3, encryptedPassword.c_str(), -1, SQLITE_STATIC);

            // Execute the statement
            rc = sqlite3_step(stmt);
            if (rc != SQLITE_DONE) {
                cerr << "Error inserting password: " << sqlite3_errmsg(db) << endl;
            } else {
                cout << "Password added successfully for " << website << endl;
                count++;
            }

            sqlite3_finalize(stmt);
        } else {
            cout << "Maximum credentials limit reached. Cannot add more passwords." << endl;
        }
    }

    void displayPasswords(bool decrypt = false) const override {
        // Vérifier si la clé de décryptage est correcte, mais seulement si l'option decrypt est vraie
        if (decrypt) {
            string decryptionKey;
            cout << "Enter Decryption Key: ";
            cin >> decryptionKey;

            if (decryptionKey != encryptionKey) {
                cout << "Decryption Key incorrect. Unable to display passwords." << endl;
                return;
            }
        }

        cout << "Stored Passwords:" << endl;

        // Select all passwords from the database and display them
        const char* selectQuery = "SELECT * FROM passwords;";
        sqlite3_stmt* stmt;
        int rc = sqlite3_prepare_v2(db, selectQuery, -1, &stmt, 0);

        while ((rc = sqlite3_step(stmt)) == SQLITE_ROW) {
            string website = reinterpret_cast<const char*>(sqlite3_column_text(stmt, 1));
            string username = reinterpret_cast<const char*>(sqlite3_column_text(stmt, 2));
            string encryptedPassword = reinterpret_cast<const char*>(sqlite3_column_text(stmt, 3));

            string displayedPassword = decrypt ? SimpleEncryption::decrypt(encryptedPassword) : "********";

            cout << "\tWebsite: " << website << ",\tUsername: " << username << ",\tPassword: " << displayedPassword << endl;
        }

        sqlite3_finalize(stmt);
    }

    void deletePassword(const string& website) override {
        // ... (votre code existant pour supprimer le mot de passe)
    }
};

int main() {
    SQLitePasswordManager passwordManager;
    int choice = 0;

    for (; choice != 6;) {
        cout << "\nPassword Manager Menu:\n"
             << "1. Add Password\n"
             << "2. Delete Password\n"
             << "3. Display Passwords\n"
             << "4. Display Decrypted Passwords\n"
             << "5. Change Encryption Key\n"
             << "6. Exit\n"
             << "Enter your choice: ";
        cin >> choice;

        switch (choice) {
            case 1: {
                // ... (votre code existant pour ajouter le mot de passe)
                break;
            }
            case 2: {
                // ... (votre code existant pour supprimer le mot de passe)
                break;
            }
            case 3:
                cout << "\n" << endl;
                passwordManager.displayPasswords();
                break;
            case 4:
                cout << "\n" << endl;
                passwordManager.displayPasswords(true); // Pass true to display decrypted passwords
                break;
            case 5:
                cout << "\nEnter New Encryption Key: ";
                cin >> encryptionKey;
                break;
            case 6:
                cout << "\nExiting...\n";
                break;
            default:
                cout << "Invalid choice. Please enter a valid option.\n";
        }
    }

    return 0;
}

